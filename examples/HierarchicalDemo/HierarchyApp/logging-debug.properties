# ================================================================================
# HIERARCHICAL LOGGING CONFIGURATION - DEBUG MODE
# ================================================================================
# This configuration demonstrates Logback-style hierarchical logging with
# wildcard patterns and specificity-based resolution.
#
# HIERARCHY RULES:
#   1. Most specific rule wins
#   2. Wildcard patterns match all children
#   3. Exact matches have priority over wildcards
#
# EXAMPLE HIERARCHY (case-sensitive):
#   App.Database.Repository.Orders (exact)
#     > App.Database.Repository.* (wildcard)
#       > App.Database.* (wildcard)
#         > App.* (wildcard)
#           > root (fallback)
#
# ================================================================================

# ROOT LOGGER
# Fallback for all loggers not explicitly configured
root=INFO

# ================================================================================
# APPLICATION HIERARCHY (App.*)
# ================================================================================
# Three main layers: UI, Business, Database
# Note: Logger names are case-sensitive

# --- UI Layer (App.UI.*) ---
# Moderate logging for UI layer
App.UI.*=INFO

# Specific UI component with detailed logging
App.UI.MainForm=DEBUG

# --- Business Layer (App.Business.*) ---
# Detailed logging for business logic
App.Business.*=DEBUG

# Even more detailed for order processing (critical component)
App.Business.OrderProcessor=TRACE

# --- Database Layer (App.Database.*) ---
# All database operations logged at DEBUG level
App.Database.*=DEBUG

# Connection management needs detailed trace logs
App.Database.Connection=TRACE

# Repository layer at INFO (less verbose than connection)
App.Database.Repository.*=INFO

# But Orders repository needs more details (critical data)
App.Database.Repository.Orders=DEBUG

# Customers repository can stay at INFO
# App.Database.Repository.Customers=INFO  # Commented = uses App.Database.Repository.* rule

# ================================================================================
# DATA PROCESSOR LIBRARY (DataProcessor.*) - FROM BPL
# ================================================================================
# Multi-level hierarchy: validation, transform (converter/mapper), export (csv/json)
# Note: Logger names are case-sensitive

# All DataProcessor components at DEBUG by default
DataProcessor.*=DEBUG

# --- Validation Layer ---
# Validation is critical, needs TRACE level
DataProcessor.Validation=TRACE

# --- Transform Layer (DataProcessor.Transform.*) ---
# Transform layer at INFO (less critical than validation)
DataProcessor.Transform.*=INFO

# But Converter needs DEBUG (more complex transformations)
DataProcessor.Transform.Converter=DEBUG

# Mapper can stay at INFO (simpler operations)
# DataProcessor.Transform.Mapper=INFO  # Uses DataProcessor.Transform.* rule

# --- Export Layer (DataProcessor.Export.*) ---
# Export operations at DEBUG (need to track what's being exported)
DataProcessor.Export.*=DEBUG

# CSV export needs TRACE (detailed file operations)
DataProcessor.Export.Csv=TRACE

# JSON export at DEBUG is sufficient
# DataProcessor.Export.Json=DEBUG  # Uses DataProcessor.Export.* rule

# ================================================================================
# RESOLUTION EXAMPLES
# ================================================================================
# Given the configuration above, here's how different loggers resolve:
# Note: Logger names and patterns are case-sensitive
#
# Logger name                           | Resolved level | Matching rule
# --------------------------------------|----------------|--------------------------------
# App.UI.MainForm                       | DEBUG          | App.UI.MainForm (exact match)
# App.UI.StatusBar                      | INFO           | App.UI.* (wildcard)
# App.Business.OrderProcessor           | TRACE          | App.Business.OrderProcessor (exact)
# App.Business.PaymentProcessor         | DEBUG          | App.Business.* (wildcard)
# App.Database.Connection               | TRACE          | App.Database.Connection (exact)
# App.Database.Repository.Orders        | DEBUG          | App.Database.Repository.Orders (exact)
# App.Database.Repository.Customers     | INFO           | App.Database.Repository.* (wildcard)
# DataProcessor.Validation              | TRACE          | DataProcessor.Validation (exact)
# DataProcessor.Transform.Converter     | DEBUG          | DataProcessor.Transform.Converter (exact)
# DataProcessor.Transform.Mapper        | INFO           | DataProcessor.Transform.* (wildcard)
# DataProcessor.Export.Csv              | TRACE          | DataProcessor.Export.Csv (exact)
# DataProcessor.Export.Json             | DEBUG          | DataProcessor.Export.* (wildcard)
# some.unconfigured.logger              | INFO           | root (fallback)
#
# ================================================================================
# TIPS FOR PRODUCTION
# ================================================================================
# For production, you typically want:
#   - root=WARN (minimal noise)
#   - Critical components=INFO or DEBUG
#   - Most wildcards=ERROR or WARN
#   - Avoid TRACE in production (performance impact)
#
# See logging.properties for production configuration example.
# ================================================================================
